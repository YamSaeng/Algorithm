#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<algorithm>

using namespace std;

//------------------------------------------------------------------------------------------------------------------------------------------------------
//어떤 자연수 p와 q가 있을 때, 만일 p를 q로 나누었을 때 나머지가 0이면 q는 p의 약수이다.
//6을 예로 들면
//6 / 1 = 6 ... 0
//6 / 2 = 3 ... 0
//6 / 3 = 2 ... 0
//6 / 4 = 1 ... 2
//6 / 5 = 1 ... 1
//6 / 6 = 1 ... 0
//그래서 6의 약수는 1, 2, 3, 6, 총 네개이다.
//두 개의 자연수 N과 K가 주어졌을 때, N의 약수들 중 K번째로 작은 수를 출력하는 프로그램을 작성하시오.
//입력
//첫째 줄에 N과 K가 빈칸을 사이에 두고 주어진다. N은 10000 이하이다.
//K는 1 이상 N 이하이다.
//출력
//첫째 줄에 N의 약수들 중 K번째로 작은 수를 출력한다.
//만일 N의 약수의 개수가 K개보다 적어서 K번째 약수가 존재하지 않을 경우에는 0을 출력하시오.
//------------------------------------------------------------------------------------------------------------------------------------------------------
void Question2501()
{
	int Array[10000];
	int Index = 0;
	int Position;
	
	memset(Array, 0, sizeof(Array));
	int Number;

	scanf_s("%d", &Number);
	scanf_s("%d", &Position);

	for (int i = 1; i <= Number; i++)
	{
		//입력받은 Number를 i(1) 부터 나눳을때 0으로 떨어지면 약수로 판단해준다.
		if (Number % i == 0)
		{
			Array[Index] = i;
			Index++;
		}
	}	

	if (Index != 0)
	{
		printf("%d", Array[Position - 1]);
	}
	else
	{
		printf("0");
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------------
//양의 정수 n이 주어졌을 때, 이를 이진수로 나타냈을 때 1의 위치를 모두 찾는 프로그램을 작성하시오.
//최하위 비트의 위치는 0이다.
//입력
//첫째 줄에 테스트 케이스의 개수 T가 주어진다.
//각 테스트 케이스는 한 줄로 이루어져 있고, n이 주어진다. (1 <= T <= 10 , 1 <= n <= 10^6)
//출력
//각 테스트 케이스에 대해서, 1의 위치를 공백으로 구분해서 줄 하나에 출력한다.
//위치가 낮은 것부터 출력한다.
//------------------------------------------------------------------------------------------------------------------------------------------------------
void Question3460()
{
	int TestNumber;
	int Number;
	int Remain;
	
	scanf_s("%d", &TestNumber);	
	
	while (TestNumber > 0)
	{
		int i = 0;

		scanf_s("%d", &Number);		

		TestNumber--;

		while (Number > 0)
		{
			Remain = Number % 2;
			if (Remain == 1) //나머지가 1이면 i위치를 출력해준다.
			{
				printf("%d ", i);
			}

			Number /= 2;
			i++;
		}
		printf("\n");
	}	
}

//------------------------------------------------------------------------------------------------------------------------------------------------------
//최소 최대
//N개의 정수가 주어진다.
//이때, 최솟값과 최댓값을 구하는 프로그램을 작성하시오.
//입력
//첫째 줄에 정수의 개수 N(1 <= N <= 1000000)이 주어진다.
//둘째 줄에는 N개의 정수를 공백으로 구분해서 주어진다.
//모든 정수는 -1,000,000보다 크거나 같고, 1,000,000보다 작거나 같은 정수이다.
//출력
//첫째 줄에 주어진 정수 N개의 최솟값과 최댓값을 공백으로 구분해 출력한다.
//------------------------------------------------------------------------------------------------------------------------------------------------------
void Question10818()
{
	int Number;
	int Data;

	int Max = -1000000;
	int Min = 1000000;

	scanf_s("%d", &Number);
	
	//Number만큼 반복하면서 최댓값, 최솟값을 구한다.
	for (int i = 0; i < Number; i++)
	{
		scanf_s("%d", &Data);

		if (Data > Max)
		{
			Max = Data;
		}

		if (Data < Min)
		{
			Min = Data;
		}
	}

	printf("%d %d", Min, Max);
}

//------------------------------------------------------------------------------------------------------------------------------------------------------
//지능형 기차 2
//최근에 개발된 지능형 기차가 1번역(출발역)부터 10번역(종착역)까지 10개의 정차역이 있는 노선에서 운행되고 있다.
//이 기차에는 타거나 내리는 사람 수를 자동으로 인식할 수 있는 장치가 있다.
//이 장치를 이용하여 출발역에서 종착역까지 가는 도중 기차 안에 사람이 가장 많을 때의 사람 수를 계산하려고 한다.
//단, 이 기차를 이용하는 사람들은 질서 의식이 투철하여, 역에서 기차에 탈 때, 내릴 사람이 모두 내린 후에 기차에 탄다고 가정한다.
//				 내린 사람 탄 사람
//1번역(출발역)		0		32
//2번역				3		13
//3번역				28		25
//4번역				17		5
//5번역				21		20
//6번역				11		0
//7번역				12		12
//8번역				4		2
//9번역				0		8
//10번역(종착역)	21		0
//예를 들어, 위와 같은 경우 기차 안에 사람이 가장 많은 때는 2번역에서 3명의 사람이 기차에서 내리고,
//13명의 사람이 기차에 탔을 때로, 총 42명의 사람이 기차 안에 있다.
//이 기차는 다음 조건을 만족하면서 운행된다고 가정한다.
//1. 기차는 역 번호 순서대로 운행한다.
//2. 출발역에서 내린 사람 수와 종착역에서 탄 사람 수는 0이다.
//3. 각 역에서 현재 기차에 있는 사람보다 더 많은 사람이 내리는 경우는 없다.
//4. 기차의 정원은 최대 10,000명이고, 정원을 초과하여 타는 경우는 없다.
//10개의 역에 대해 기차에서 내린 사람 수와 탄 사람 수가 주어졌을 때, 기차에 사람이 가장 많을 때의 사람 수를 계산하는 프로그램을 작성하시오.
//입력
//각 역에서 내린 사람 수와 탄 사람 수가 빈칸을 사이에 두고 첫째 줄부터 열 번째 줄까지 역 순서대로 한 줄에 하나씩 주어진다.
//출력
//첫째 줄에 최대 사람 수를 출력한다.
//------------------------------------------------------------------------------------------------------------------------------------------------------
void Question2460()
{
	int Sum = 0;
	int LetDownPeople;
	int ToRidePeople;
	int Max = -999999;

	//10번 반복하면서 내린사람, 탄사람의 합을 구하고 그 중 가장 큰 합을 구해준다.
	for (int i = 0; i < 10; i++)
	{
		scanf_s("%d %d", &LetDownPeople, &ToRidePeople);

		Sum = Sum - LetDownPeople + ToRidePeople;

		if (Sum > Max)
		{
			Max = Sum;
		}
	}

	printf("%d", Max);
}

//------------------------------------------------------------------------------------------------------------------------------------------------------
//피보나치 수
//피보나치 수는 0과 1로 시작한다. 
//0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다.
//그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.
//이를 식으로 써보면 Fn = Fn-1+Fn-2(n>=2)가 된다.
//n=17일때 까지 피보나치 수를 써보면 다음과 같다.
//0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597
//n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오.
//입력
//첫째 줄에 n이 주어진다. n은 20보다 작거나 같은 자연수 또는 0이다.
//출력
//첫째 줄에n번째 피보나치 수를 출력한다.
//------------------------------------------------------------------------------------------------------------------------------------------------------
void Question10870()
{
	int Number;

	scanf_s("%d", &Number);

	int* Array = (int*)malloc(sizeof(int)*(Number + 1));
	
	//첫번째와 두번째 피보나치 수 0 과 1 저장
	Array[0] = 0;
	Array[1] = 1;

	//3번째 부터 피보나치 수열을 구해주는데 전전과 전 값을 더해서 저장해준다.
	for (int i = 2; i < Number + 1; i++)
	{
		Array[i] = Array[i - 2] + Array[i - 1];
	}

	printf("%d",Array[Number]);

	free(Array);
}

//------------------------------------------------------------------------------------------------------------------------------------------------------
//일곱 난쟁이
//왕비를 피해 일곱 난쟁이들과 함께 평화롭게 생활하고 있던 백설공주에게 위기가 찾아왔다.
//일과를 마치고 돌아온 난쟁이가 일곱 명이 아닌 아홉 명이었던 것이다.
//아홉 명의 난쟁이는 모두 자신이 "백설 공주와 일곱 난쟁이"의 주인공이라고 주장했다.
//뛰어난 수학적 직관력을 가지고 있던 백설공주는, 다행스럽게도 일곱 난쟁이의 키의 합이 100이 됨을 기억해 냈다.
//아홉 난쟁이의 키가 주어졌을 때, 백설공주를 도와 일곱 난쟁이를 찾는 프로그램을 작성하시오.
//입력
//아홉 개의 줄에 걸쳐 난쟁이들의 키가 주어진다.
//주어지는 키는 100을 넘지 않는 자연수이며, 아홉 난쟁이의 키는 모두 다르며, 가능한 정답이 여러 가지인 경우에는 아무거나 출력한다.
//출력
//일곱 난쟁이의 키를 오름차순으로 출력한다.
//일곱 난쟁이를 찾을 수 없는 경우는 없다.
//------------------------------------------------------------------------------------------------------------------------------------------------------
void Question2309()
{	
	int Sum = 0;
	bool Flag = false;	

	int* Array = (int*)malloc(sizeof(int)*9);

	for (int i = 0; i < 9; i++)
	{
		scanf_s("%d", &Array[i]);
		//키 총합을 구해둔다.
		Sum += Array[i];
	}

	//미리 정렬해둔다.		
	sort(Array, Array + 9);

	//9명중 7명의 키가 100이 되는 말은 
	//9명의 총합 키에서 2명의 키를 뺏을때 그 값이 100이 된다는 말과 같다.
	for (int i = 0; i < 8; i++)
	{
		for (int j = 1; j < 9; j++)
		{			
			//총합키에서 2 항목의 값을 뺏을때 100이 되면
			//해당 인덱스를 제외하고 출력해준다.
			if (Sum - (Array[i] + Array[j]) == 100)
			{
				Flag = true;
				for (int k = 0; k < 9; k++)
				{
					if (k != i && k != j)
					{
						printf("%d\n", Array[k]);
					}
				}
				break;
			}
		}

		if (Flag == true)
		{
			break;
		}
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------------------
//최대공약수와 최소공배수
//두 개의 자연수를 입력받아 최대 공약수와 최소 공배수를 출력하는 프로그램을 작성하시오.
//입력
//첫째 줄에는 두 개의 자연수가 주어진다.
//이 둘은 10000이하의 자연수이며 사이에 한 칸의 공백이 주어진다.
//출력
//첫째 줄에는 입력으로 주어진 두 수의 최대공약수를,
//둘째 줄에는 입력으로 주어진 두 수의 최소 공배수를 출력한다.
//------------------------------------------------------------------------------------------------------------------------------------------------------
void Question2609()
{
	int Array[10001];
	int NumberOne;
	int NumberTwo;
	//최대 공약수
	int Max = 1;
	//최소 공배수
	int Min;

	memset(Array, 0, sizeof(Array));
	
	scanf_s("%d %d", &NumberOne, &NumberTwo);
	
	//첫번째 수 약수 구하기
	for (int i = 1; i <= NumberOne; i++)
	{
		if (NumberOne % i == 0)
		{
			Array[i]++;
		}
	}

	//두번째 수 약수 구하기
	for (int i = 1; i <= NumberTwo; i++)
	{
		if (NumberTwo % i == 0)
		{
			Array[i]++;
		}
	}
	
	//최대 공약수 구하기
	for (int i = 1; i <= 10000; i++)
	{
		if (Array[i] == 2)
		{
			if (i > Max)
			{
				Max = i;
			}
		}
	}	

	//최대 공약수로 수 나누기
	int NumberOneMin = NumberOne / Max;
	int NumberTwoMin = NumberTwo / Max;
	
	//최대 공약수로 나눈 몫과 최대 공약수 곱해서 최소 공배수 구하기
	Min = NumberOneMin * NumberTwoMin * Max;

	printf("%d\n%d", Max, Min);
}

int main()
{
	Question2609();
	return 0;
}